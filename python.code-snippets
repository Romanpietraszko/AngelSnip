{
	 "Pętla/For": {                                                   
		"prefix": "pętlafor",
	 	"body": [
	 		"for ${1:i}  in range(${2:5}):",
	 		"    ${0:# TODO: coś zrób}"
	 	],
	 	"description": "składnia pętli for wstawia z opisem"
	 },
	 
	"funkcja":{
		"prefix": "funkcja",
		"body": [
			"def ${1:nazwa_funkcji}(${2:arg1},${3:arg2})",
			"   ${0:# Todo: return}"
		],
		"description": "Wzór funkcji"	
	 },
	 "Klasa":{
		"prefix": "Class",
		"body": ["class${1:NazwaKlasy}:",
		"def __init__(self,${2:argument1},${3:argument2}):",
			"self.${2:argument1} = ${2:argument1}",
			 "self.${3:argument2} = ${3:argument2}",
		 "def ${4:metoda}(self):",
		 	" ${0:#ciało metody}",
			 "return coś"

	 ],
	 "description": "Składnia klasy"       
	 },
	 "Pętla/while":{
		"prefix": "while",
		"body":[ "while True",
				 "    ${0:# Todo: zrob coś}"
	],
	"description":"Składnia pętli while nie skończonej"
	 },
	 "Pętla/while/Z/warunkiem":{
		"prefix": "while not",
		"body":[ "while not ${1:jakiś_warunek():}",
				 "   ${0:# Todo np: jakiś_warunek = cokolwiek()}"
	],
	"description":"Składnia pętli while not z warunkiem"
	 },
	  "Pętla/while/Z/Licznikiem":{
		"prefix": "while licznik",
		"body":[ "${1:i} = ${2:0}",
    		"while ${1:i} < ${3:5}:",
    		"    ${4:print(${1:i})}",
    		"    ${1:i} += 1",
    		"${0}"
	],
	"description":"Składnia pętli while z licznikiem"
	 },
	 "Pętla/while/z/Przerwaniem":{
		"prefix": "while break",
		"body":[   "while True:",
   				   "    ${1:warunek} = ${2:input(\"Podaj coś: \")}",
   				   "    if ${1:warunek} == ${3:\"exit\"}:",
   					 "        break",
   				   "    ${0:# TODO: zrób coś z warunkiem}"
  ],
	 "description": "Pętla while z przerwaniem"
	 },
	 "ifpodstawowy": {
	 "prefix": "if",
  	 "body": [
		"if ${1:warunek}:",
		"   ${0:#Todo kod do wykonania}"
  ],
  "description": "Podstawowy if"
},
	"ifzelse": {
	  "prefix": "ifelse",
	  "body": [
		"if ${1:warunek}:",
		"   ${2:#Todo kod jeśli warunek prawdziwy}",
		"else:",
		"   ${0:#Todo kod jeśli warunek jest fałszywy}"
	  ],
	  "description": "Opis"
	},
	"if/else/elif": {
	  "prefix": "ifelseelif",
	  "body": [
		"if ${1:warunek}:",
		"${2:#kod jeśli warunek}",
		"elif${3:#warunek 2}:",
		"${4:#kod jeśli warunek2}",
		"else:",
		"#kod jeśli żaden nie spełniony"
	  ],
	  "description": "if z elif i z else"
	},
	"if/zagnieżdrzony": {
	  "prefix": "ifzif",
	  "body": [
		"if ${1:warunek}:",
		"   if ${2:warunek}:",
		"    ${0:#Kod jeśli oba warunki}"
	  ],
	  "description": "Zagnieżdrzony if"
	},
	"jedno/linikowy/warunek": {
	  "prefix": "krótkiif",
	  "body": [
		"${1:warunek} if warunek else ${0:przeciwny warunek}"
		
	  ],
	  "description": "jedno linijkowy if z else"
	},
	"Łączeniewarunków": {
	  "prefix": "ŁączenieWarunków",
	  "body": [
		"if ${1:warunek logiczny} and ${2:warunek logiczny inny}",
		"if ${2:warunek logiczny 2} or ${3:warunek inny kolejny}",
		"if not ${0: np is_ready}"
	  ],
	  "description": "łączenie warunków "
	},
	"Porównanialogiczne": {
  	"prefix": "porwónajlogicznie",
  	"body": [
	"if a == b",
	"if a != b",
	"if a > b",
	"if a < b ",
	"if a >= b",
	"if a <= b "
  	],
  	"description": "Porównania logiczne xd"
	},
	"try/except/Klasyczna/Obsługa/Błędów": {
  	"prefix": "try/except",
  	"body": [
	 "try:",
	"   ${1:#kod}",
	"except Expection as e:",
	"    ${0:#kod obsługa błędu}"
  ],
  "description": "Klasyczna obsługa błędów"
},
  "try/except/finally/ObsługaBłędów/Z/Blokiem/który/zawsze/sie/Wykona": {
	  "prefix": "try/except/finally",
	  "body": [
		"try:",
		"   ${1:#kod}",
		"except:",
		"   ${2:# kod obsługa błędu}",
		"finally:",
		"   ${0:#Kod który zawsze się wykona}"
	  ],
	  "description": "Obsługa błędów z blokiem finaly który zawsze się wykona"
	},
	"raise/Reczne/Rzucenie/Wyjątku": {
	  "prefix": "raise",
	  "body": [
		"raise Exception(${0:#treść komunikat błędu})"
	  ],
	  "description": "Reczne rzucenie wyjątku"
	},
	"assert/szybka/Walidacja/Warunku": {
	  "prefix": "assert",
	  "body": [
		"assert, ${1:#warunek()}"
	  ],
	  "description": "Szybka walidacja warunku"
	},
	"except/z/wieloma/typami/błędu": {
	  "prefix": "exceptzwielomatypamibłędu",
	  "body": [
		"try:",
		"   ${1:#Todo kod}",
		"except(TypeError,ValueError)as e:",
		"   ${0:#obsuga}"
	  ],
	  "description": "Składnia except obsługującego wiele typów błędów"
	},
	"Otwieranie/pliku/do/odczytu": {
	  "prefix": "withopen",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','r'}) as f:",
		"    ${0:#Todo dane = f.read()}"
	  ],
	  "description": "Otwieranie pliku do odczytu"
	},
	"Otwieranie/pliku/do/zapisu": {
	  "prefix": "withopenw",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','w'}) as f:",
		"   ${0:#Todo f.write('tekst')}"
	  ],
	  "description": "Otwieranie pliku do zapisu(nadpisuje)"
	},
	"Otwieranie/pliku/do/dopisania": {
	  "prefix": "withopen",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','a'}) as f:",
		"${0:#Todo  f.write('dopisany tekst')}"
	  ],
	  "description": "Otwieranie pliku do dopisania"
	},
	"Otczyt/linia/po/lina": {
	  "prefix": "withopenfor",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','r'}) as f:",
		"   ${1:#for linia in f:}",
		"       ${0:#print (linia)}"
	  ],
	  "description": "Wzrór odczytu linia po lini"
	},
	"Sprawdzenie/czy/plik/istnieje": {
	  "prefix": "sprawdzczyplikistnieje",
	  "body": [
		"import os",
		"if os.path.exists(${1:#'nazwa_pliku.txt'}):",
		"    ${0:#Coś zrób}"
	  ],
	  "description": "Składnia sprawdzenia czy plik istnieje"
	},
	"Usunięcie/pliku": {
	  "prefix": "usunięciepliku",
	  "body": [
		"import os",
		"os.remove(${1:#'nazwa_pliku.txt'})"
	  ],
	  "description": "Usunięcie pliku "
	},
	"lista": {
	  "prefix": "list",
	  "body": [
		"#lista uporządkowana: list = [1,2,3]",
		"# dodanie elementu na koniec: list.append(4)",
		"#usunięcie elementu: list.remove(2)",
		"#usunięcie ostatniego elementu: list.pop() ",
		"#sortowanie listy rosnąco: list.sort()",
		"# odwrócenie kolejności elementów: list.reverse()"
	  ],
	  "description": "Opis"
	},
	"słownik": {
	  "prefix": "dict",
	  "body": [
		"#Słownik nie uporządkowany kolekcja par: dict = {'klucz':'wartość'}",
		"#dodanie nowej pary: dict['nowy'] = 'dodany' ",
		"#Pobieranie wartości z klucza: dict = słownik.get('klucz')",
		"#Usunięcie pary z kluczem: del dict['klucz']"
	  ],
	  "description": "Opis"
	},
	"Zbiór": {
	  "prefix": "zbiór",
	  "body": [
		"#zbiór to nieuporządkowana kolekcja unikalnych elmentów: zbiór = {1,2,3}",
		"#dodanie elementu: zbiór.add(4)",
		"#Usunięcie elementu: zbiór.remove(2)",
		"#Dodanie wielu elementów naraz: zbiór.update({5,6})"
	  ],
	  "description": "Zbiór i operacje na zbiorach"
	},
	"Krotka/tuple": {
	  "prefix": "krotkatuple",
	  "body": [
		"#krotka = (1,2,3)",
		"#wartość = krotka[0]"
	  ],
	  "description": "Krotka inaczej zwana tuple"
	},
	"List/comprehension": {
	  "prefix": "listcomprehension",
	  "body": [
		"Skrótowa forma tworzenia listy na podstawie innej listy często z warunkiem",
		"nowa_lista = [${1:#np. x for x in lista if x >0}]"
	  ],
	  "description": "List comprehension"
	},
	"Iteracja/po/słowniku": {
	  "prefix": "iteracjaposłowniku",
	  "body": [
		"for klucz,wartość in słownik.items()",
		"   ${0:#print(klucz,wartość)}"
	  ],
	  "description": "Iteracja po słowniku"
	},
 "ImportModułu": {
   "prefix": "Import",
   "body": [
	 "import nazwa_modułu" 
   ],
   "description": "Import całego modułu"
 },
"Import/Z/aliasem": {
  "prefix": "importzaliasem",
  "body": [
	"import nazwa_modułu as alias"
  ],
  "description": "Import z aliasem"
},
"import/konkretnej/funkcji/klasy": {
  "prefix": "importkonkretnejfunkcjiklasy",
  "body": [
	"from nazwa_modułu import funkcja"
  ],
  "description": "wielu importów konkretnej funkcji/klasy"
},
"Import/z/aliasem/konkretnego/elementu": {
  "prefix": "importzaliasemkonkretnegoelementu",
  "body": [
	"from nazwa_modułu import funkcja as alias"
  ],
  "description": " wzór importów z aliasem konktetnego elementu"
},
"Import/wielu/elementów": {
  "prefix": "importwieluelementów",
  "body": [
	"from nazwa_modułu import funkcja1,funkcja2, Klasa"
  ],
  "description": "Wzór importu wielu elementów"
},
"Import/wszystkiego": {
  "prefix": "importwszystkiego",
  "body": [
	"form nazwa_modułu import *"
  ],
  "description": "Niezalecany import wszystkiego"
},
"@decorator": {
  "prefix": "@decorator",
  "body": [
	"@decorator",
	"def funkcja():",
	"   #ciało funkcji"
  ],
  "description": "dekorator do nakładania dodatkowej logiki"
},
"@decorator(argument)": {
  "prefix": "@decorator(argument)",
  "body": [
	"@decorator(${1:argument})",
	"def funkcja():",
	"   ${0:#ciało funkcji}"
  ],
  "description": "dekorator z parametrem"
},
"@staticmethod": {
  "prefix": "@staticmethod",
  "body": [
	"class Klasa:",
	"   @staticmethod",
	"   def funkcja():",
	"       # ciało funkcji"
  ],
  "description": "Metoda niezależna od instacji klasy-nie używa self"
},
"@classmethod": {
  "prefix": "@classmethod",
  "body": [
	"class Klasa:",
	"   @classmethod",
	"   def funkcja():",
	"       # ciało funkcji"
  ],
  "description": "Metoda działająca na klasie, nie na obiekcie — używa cls zamiast self."
},
"Własny/dekorator": {
  "prefix": "własnydekorator",
  "body": [
	"def dekorator(${1:funkcja}):",
	   "def wrapper(*args,**kwargs):",
	"    ${2:#coś przed}",
	"    wynik = funkcja(${3:#*args,**kwargs})",
	"    ${4:#coś po}",
	"     return wynik",
	"return wrapper"
  ],
  "description": "Tworzysz własny „filtr” na funkcję — np. dodajesz logikę, walidację, cache."
},
"PobieranieDanychzAPI": {
  "prefix": "pobieraniedanychzapi",
  "body": [
	"import requests",
	"response = requests.get('https://example.com)",
	"data = response.json()"
  ],
  "description": "Pobieranie danych z API"
},
"Wysyłaniedanychdoapi": {
  "prefix": "wysyłkadanychdoAPI",
  "body": [
	"import requests",

	"playload = {'key':'value'}",
	"response = requests.post('https://example.com/api', json=payload)"
  ],
  "description": "Wysłanie zapytania Post z danymi w formacie Json do API"
},
"AsnychronicznePobranieDanych": {
  "prefix": "AsynchronicznePobranieDanych",
  "body": [
	"import httpx",
	"import asyncio",
	"async def fetch():",
	"   async with httpx.AsyncClient() as clinet:",
	"       response = await clinet.get('https://example.com')",
	"       data = response.json()"
  ],
  "description": "Umożliwia pobieranie danych w sposób asynchroniczny-przydatne w fast api"
},
"NumPy operacje na macierzach": {
  "prefix": "Podstawowy_typ_danych_w_ML_do_matmy",
  "body": [
	"import numpy as np",
	"macierz = np.array([[1,2],[3,4]])"
  ],
  "description": "Tworzy dwumywiarową macierz(array),podstawowy typ danych w ML do obliczeń matmatycznych"
},
"Pandas manipulacja danymi": {
  "prefix": "Wczytywanie_danych_z_pliku_CSV_i_modifikowanie_kolumny",
  "body": [
	"import pandas as pd",
	"df = pd.read_csv('plik.csv')",
	"df['kolumna'] = df['kolumna'].apply(lambda x: x *2)"
  ],
  "description": "Wczytuje dane z pliku CSV i modyfikuje kolumnę — Pandas to must-have do pracy z danymi tabelarycznymi."
},
"Scikit-learn klasyczne ML": {
  "prefix": "Tworzenie_modelu_regresji_logistycznej_trenowanie_i_przewidywanie_wyników_klasyczny_ML_workflow",
  "body": [
	"form sklearn.linear_model import LogisticRegresion",
	"model = LogisticRegresion()",
	"model.fit(X_train, y_train)",
	"pred = model.predict(X_test)"
  ],
  "description": "Tworzy model regresji logistycznej, trenuje go na danych i przewiduje wyniki — klasyczny ML workflow."
},
"TensorFlow deep learning": {
  "prefix": "definiuj_i_trenuj_sieć_neuronową_w_TensorFlow",
  "body": [
	"import tensorflow as tf",
	"model = tf.keras.Sequential([])",
	"model.compile(optimizer = 'adam',loss = 'mse')",
	"model.fit(X,y epochs = 10)"
  ],
  "description": "Definiuje i trenuje sieć neuronową w TensorFlow — używane w projektach deep learningowych."
},
"Tworzenie interfejsu CLI z opcjami nazwa i debug": {
  "prefix": "Interfejs_CLI_z_opcjami_debug_nazwa_automatycznehelp",
  "body": [
	"import argparse",
	"",
    "parser = arparse.ArgumentyParser(description = 'Opis Programu')",
    "parser.add_argument('--nazwa',type = str, help = 'podaj nazwę])",
	"parser.add_argument('--debug',action = 'store_true', help = 'tryb debugowania')",
	"args = parser.parse_args()",
    "print(args.nazwa)"
  ],
  "description": "worzy interfejs CLI z opcjami --nazwa i --debug. Automatycznie generuje help."
},
	"Średniej wielkości apka": {
	  "prefix": "średniaapka",
	  "body": [
		"#===Importy===",
		"import logging",
		"#Konfiguracja logowania",
		"logging.basicConfig(level=logging.INFO)",
		"#Klasa 1",
		"class User: ",
		"     def __init__(self,${1:name}:",
		"         self.${1:name} = ${1:name}",
		"     def greet(self): ",
		"         pass #tu dodaj powitanie użytkownika",
		"#Klasa 2",
		"class Product: ",
		"    def __init__(self,${2:title},${3:price}):",
		"       self.${2:title} = ${2:titile}",
		"       self.${3:price} = ${3:price}}",
		"    def apply_discount(self,${4:user},${5:products}):",
		"       self.${4:user} = ${4:user}",
		"       self.${5:products} = ${5:products}",
		"    def calculate_total(self):",
		"        pass #Tu oblicz sumę zamówienia",
		"#Funkcja pomocnicza ",
		" def run_app():",
		"    pass # Tu uruchom aplikację",
		" # Punkt wejścia",
		" if __name__ == '__main__':",
		"    run_app()"
	  ],
	  "description": "Szablon aplikacji średniej z 3 klasami paroma funkcjami"
	},
	"Prototyp v1": {
	  "prefix": "prototypv1",
	  "body": [
		"=== CLI ===",
		"import argparse",
		"import streamlit as st",
		"import yaml",
	    "",
       "parser = argparse.ArgumentParser(description = 'Generator prototypów')",
       "parser.add_argument('--nazwa',required=True)",
	   "parser.add_argument('--komponenty',nargs='+')",
	   "args = parser.parse_args()",
	   "=== Generowanie klasy ===",
	   "def generuj_klasę(nazwa,atrybuty):",
        "   linie = [f'class {nazwa}:']",
		"   linie.append('    def __init__(self,'+','.join(atrybuty)+'):')",
        "   for a in atrybuty:",
		"      linie.append(f'     self.{a} ={a}')",     
        "   return '\n'.join(linie)",
		"# === UI(Streamlit) ===",
		"st.title('Generator Prototypów')",
        "nazwa = st.text_input('Nazwa aplikacji')",
		"komponenty = st.multiselect('Wybierz komponenty',['UI','Backend','AI'])",
        "if st.button('generuj'):",
		"    st.code(generuj_klase(nazwa, komponenty), language = 'python')",
		"# === Prasowaniem YAML ===",
		"def wczytaj_konfiguracje(plik):",
		"  with open(plik) as f:",
		"      return yaml.safe_load(f)",
		"# === AI Podpowiedzi ===",
		"def podpowiedz_snippet(prompt):",
		"# Tu wrzucam zapytanie do AI",
		"# tu mam dostać kod jako string",
		"pass # Placeholder",
		"# === Punkt wejścia ===",
		"if __name__ == '__main__':",
        "   print(generuj_klase(args.nazwa, args.komponenty))"
	  ],
	  "description": "Optymalnie do robienia prototypów z podpięciem AI i streamlit i yaml"
 },
     "WzórSkryptu": {
    "prefix": "wzórskryptu",
    "body": [
	   "import os",
	   "import sys",
	   "#Funkcja główna",
	   "def main():",
	   "    #Tu wpisz logikę programu",
	   "    pass",
	   "# Punkt wejścia",
	   "if __name__=='__main__':",
	   "    main()"
    ],
     "description": "Podstawowy wzór skryptu"
},
}
